// SETP 1: SETTING UP THE GEOMETRY AND CENTERING THE MAP
  //Right now I want to try and look at the florida Everglades before irma in 2017
  // Dates for season: 1/12/2016 to 31/05/2017

Map.centerObject(aoi, 8);

//STEP 2: CALCULATING THE INDECIS AND DOWNLOADING SENTINEL 2 DATA 

//2.1 Select the period of interest 
  //in this case we are going to be using the months pre-hurricane season 2017 
    //This methodology has been widely used to study mangroves and has proven to be appropriate 
var startDate = '2016-12-01';
var endDate = '2017-05-31';
  //This is useful because then we can use the start and end date when downloading S1 data as well

//2.2 function for Calculating Indices 

//NDVI = (NIR-Red)/(NIR+Red)
var addNDVI = function(image) {
return image.addBands(image.normalizedDifference(['B8', 'B4']).rename('NDVI'));
};

//NDWI = (Green-NIR)/(Green-NIR)
var addNDWI = function(image) {
return image.addBands(image.normalizedDifference(['B3', 'B8']).rename('NDWI'));
};

//MNDWI = (Green-SWIR)/(Green+SWIR)
var addMNDWI = function(image) {
return image.addBands(image.normalizedDifference(['B3', 'B6']).rename('MNDWI'));
};

//Simple Ratio (SR) = NIR/Red
var addSR = function(image) {
return image.addBands(image.select('B8').divide(image.select('B4')).rename('SR'));
};

//2.3 Selecting the Sentinel 2 data for the area of interest 
var S2_IC_temp = ee.ImageCollection('COPERNICUS/S2')
//filter start and end date
.filterDate(startDate, endDate)
.map(addNDVI)
.map(addNDWI)
.map(addMNDWI)
.map(addSR)
//filter according to drawn boundary 
.filterBounds(aoi);

print('Sentinel 2 Image Collection before CMRI',S2_IC_temp);

//Adding the Combined Mangrove Recognition Index (CMRI) = NDVI - NDWI (Yancho et al. 2018)

var addCMRI = function(image) {
return image.addBands(image.select('NDVI').subtract(image.select('NDWI')).rename('CMRI'));
};

var S2_IC = S2_IC_temp.map(addCMRI)

print(S2_IC)

//2.4 Cloud Masking 
var S2withCloudMask = ee.Join.saveFirst('cloud_mask').apply({
primary: S2_IC,
secondary: S2_CLOUD_PROBABILITY,
condition: ee.Filter.equals({leftField: 'system:index', rightField: 'system:index'})
});
S2withCloudMask = ee.ImageCollection(S2withCloudMask);

// define a function to mask-out clouds from each image
var maskClouds = function(img) {
var clouds = ee.Image(img.get('cloud_mask')).select('probability');
var isNotCloud = clouds.lt(10);
return img.mask(isNotCloud);
};

var S2 = S2withCloudMask.map(maskClouds);

//print('Sentinel 2 cloud masked', S2);

//NB: There are several ways in wich cloud masking can be done, not sure this is the best one, think about it 

var S2_composite = S2.median();

//print(S2_composite) //this is an image not an image collection

//2.5 Showing the composite images of NDVI, RGB and False colorù

  //Map.addLayer(S2_composite.clip(aoi), {min:0, max:3000, bands:["B4", "B3", "B2"]}, "RGB Composite");
  //Map.addLayer(S2_composite.clip(aoi), {min:0, max:3000, bands:["B8", "B4", "B3"]}, "False color composite");

//Creating an NDVI palette
var ndvi_pal = ['#40004B', '#762A83', '#9970AB', '#C2A5CF', '#E7D4E8',
'#D9F0D3', '#A6DBA0', '#5AAE61', '#1B7837', '#00441B'];

//Display NDVI results on map
//Map.addLayer(S2_composite.clip(aoi), {min:-0.5, max:0.9, bands: ["NDVI"], palette: ndvi_pal}, 'NDVI pre-Irma');


//2.6 Creating a Linechart for NDVI pro
//var plotNDVI = ui.Chart.image.seriesByRegion(S2, aoi,ee.Reducer.mean(),
//'NDVI',500, 'system:time_start', 'system:index')
 //             .setChartType('LineChart').setOptions({
 //               title: 'NDVI pre-Irma time series',
//                hAxis: {title: 'Date'},
      //          vAxis: {title: 'NDVI'}
//});

//print(plotNDVI); //NB: you can download the CSV for the plot from the image 

//3.1 Preparing training data and predictors

var classes = Mangroves.merge(NonMangrove); //merging them into a single feature collection

var bands = ['B8','B11','B4','NDVI','MNDWI', 'CMRI', 'SR', 'NDWI']

//old bands --> ['B8','B11','B4','NDVI','MNDWI']; // defyining the bands we care about for the model 

//Create a variable called image to select the bands of interest and clip to geometry
var image = S2_composite.select(bands).clip(aoi);

//print(image);

//Assemble samples for the model
  //this pulls out what values we are seeing for the areas in our training polygons 
var samples = image.sampleRegions({
    collection: classes, // Set of geometries selected for training
    properties: ['landcover'], // Label from each geometry
    scale: 10 // Make each sample the same size as Sentinel pixel
    }).randomColumn('random'); // creates a column with random numbers

//Here we randomly split our samples to set some aside for testing our model's accuracy
//using the "random" column we created
var split = 0.8; // Roughly 80% for training, 20% for testing.
var training = samples.filter(ee.Filter.lt('random', split)); //Subset training data
var testing = samples.filter(ee.Filter.gte('random', split)); //Subset testing data

    
//Print these variables to see how much training and testing data you are using
//    print('Samples n =', samples.aggregate_count('.all'));
//    print('Training n =', training.aggregate_count('.all'));
//    print('Testing n =', testing.aggregate_count('.all'));

//3.2) Begin Random Forest Classification

//.smileRandomForest is used to run the model. Here we run the model using 100 trees
// and 5 randomly selected predictors per split ("(100,5)")
    var classifier = ee.Classifier.smileRandomForest(100,6).train({ 
    features: training.select(['B8','B11','B4','NDVI','MNDWI', 'CMRI', 'SR', 'NDWI','landcover']), //Train using bands and landcover property
    classProperty: 'landcover', //Pull the landcover property from classes
    inputProperties: bands
    });

//View explain to see how each band contributes to the classifier
print(classifier.explain(),'Explain');

//3.3) Test the accuracy of the model

    var validation = testing.classify(classifier);
    var testAccuracy = validation.errorMatrix('Landcover', 'classification');
    print('Validation error matrix RF: ', testAccuracy);
    print('Validation overall accuracy RF: ', testAccuracy.accuracy());

//I get a user memory limit issue 
  //link here to try and solve it: https://gis.stackexchange.com/questions/325713/gee-accuracy-assessment-of-classification-user-memory-limit-exceeded
  
//3.4 - Classify the Landsat composite using the Random Forest model
var classifiedrf = image.select(bands) // select the predictors
    .classify(classifier); // .classify applies the Random Forest
                      
//The model results may be "noisy". To reduce noise, create a mask to mask
// unconnected pixels
var pixelcount = classifiedrf.connectedPixelCount(100, false); //Create an image that shows the number of pixels each pixel is connected to
var countmask = pixelcount.select(0).gt(25); //filter out all pixels connected to 4 or less 

//Mask the results to only display mangrove extent
var classMask = classifiedrf.select('classification').gt(0);
var classed = classifiedrf.updateMask(countmask).updateMask(classMask);


//3.5 - Map results

//Add classification to map
  //Map.addLayer (classed, {min: 1, max: 1, palette:'blue'}, 'Mangrove Extent pre Irma Optical');

//We can compare this to the new 2017 map of mangroves in the GMW 

//3.6 Vectorising the results so we can run the code more quickly 
  //commenting this off cause it was successful
  
//var mangVect = classed.reduceToVectors({ geometry:aoi,
//scale:10,
//geometryType: 'polygon', maxPixels:1e13,
//labelProperty: 'class',});

//Map.addLayer(mangVect,{},'Mangrove Extent Vector');

//Export.table.toAsset({
//collection: mangVect, 
//description:'Vectorised_preIrma'});

//STEP 4: ADDING SENTINEL-1 SAR DATA 
//4.1) Filter Sentinel data to date and region of interest

var sentinel1 = ee.ImageCollection('COPERNICUS/S1_GRD')
            .filterDate(startDate, endDate)
            .filterBounds(aoi)
            .filter(ee.Filter.eq('resolution_meters',10));

//print('Sentinel 1 data', sentinel1);

//4.2) Get Sentinel's dual polarization

// Filter by metadata properties.
var vh = sentinel1
  //Filter to get images with VV and VH dual polarization.
  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))
  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'))
  // Filter to get images collected in interferometric wide swath mode.
  .filter(ee.Filter.eq('instrumentMode', 'IW'));
  
// Filter to get images from different look angles.
var vhAscending = vh.filter(ee.Filter.eq('orbitProperties_pass', 'ASCENDING'));
var vhDescending = vh.filter(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'));

//4.3) Create a composite from means at different polarizations and look angles.
var S1composite = ee.Image.cat([
  vhAscending.select('VH').mean(),
  ee.ImageCollection(vhAscending.select('VV').merge(vhDescending.select('VV'))).mean(),
  vhDescending.select('VH').mean()
]).focal_median();

//print('S1 Composite', S1composite);

//4.4) Display results
//Display as a composite of polarization and backscattering characteristics.

Map.addLayer(S1composite.clip(aoi), {min: [-25, -20], max: [0, 10]}, 'Sentinel Composite');

//STEP 5: REBUILDING A RFC WITH THE SAR DATA 
  //in this case we are going to be using the same training data
    //essentially we use SAR as a way to improve on mangrove classification to make it more precise and in order to include structure as well 

//5.1 Clipping Sentinel 1 observations to sentinel 2 results (this is done using the vectorised pre irma land class)

var FinalComposite = S1composite.clip(mangVect);
print('Final Composite',FinalComposite) //così mi dice che ha solo due bands 

//5.2 Assembling samples that are going to be used for the model

var S1bands = ['VV','VH']; //bands I want in the model

var S1samples = FinalComposite.select(S1bands).sampleRegions({
collection: classes, // Set of geometries selected in 4.1
properties: ['landcover'], // Label from each geometry
scale: 10 // Make each sample the same size as Landsat pixel
}).randomColumn('random_S1'); // creates a column with random numbers


var splitS1 = 0.8; // Roughly 80% for trining, 20% for testing.
var trainingS1 = S1samples.filter(ee.Filter.lt('random_S1', split)); //Subset training data
var testingS1 = S1samples.filter(ee.Filter.gte('random_S1', split)); //Subset testing data

    
//Print these variables to see how much training and testing data you are using
print('Samples n =', S1samples.aggregate_count('.all'));
print('Training n =', trainingS1.aggregate_count('.all'));
print('Testing n =', testingS1.aggregate_count('.all'));
    
    
//5.3 Begin Random Forest Classification

var S1classifier = ee.Classifier.smileRandomForest(100,2).train({ //We use 2 variables instead of 5
features: trainingS1.select(['VV','VH', 'landcover']), //S1samples
classProperty: 'landcover',
inputProperties: S1bands
});


//5.4 Classify the Sentinel composite using the Random Forest model
var S1classified = FinalComposite.select(S1bands) // select the predictors
.classify(S1classifier); // apply the Random Forest
 
//The model results may be "noisy". To reduce noise, create a mask to mask
// unconnected pixels
    var S1pixelcount = S1classified.connectedPixelCount(100, false); //Create an image that shows the number of pixels each pixel is connected to
    var S1countmask = S1pixelcount.select(0).gt(10); //filter out all pixels connected to 4 or less 

//Mask the results to only display mangrove extent
    var S1classMask = S1classified.select('classification').gt(0);
    var S1classed=  S1classified.updateMask(S1countmask).updateMask(S1classMask);

//5.5 Map results

//Add classification to map
//Map.addLayer (GMW_16, {color:'#8d5a99'}, 'GMW 2016');

Map.addLayer (S1classed, {min: 1, max: 1, palette: '#b8ca2e'}, 'Mangrove Extent pre Irma SAR');
//Map.addLayer (classed, {min: 1, max: 1, palette:'#8d5a99'}, 'Mangrove Extent pre Irma Optical');

//Based on this there is a big difference between only optical and optical as well as SAR
  //much more detail on meadirng fjord like islands
  //much more detail about mangroves in the inside and surrounding the lakes 
  //can be also 

//STEP 6: EVALUATING THE MODEL
//6.1. Using the testing data to find the accuracy of the model with confusion matric 
  //link here: https://developers.google.com/earth-engine/apidocs/ee-classifier-smilerandomforest
  
// Get information about the trained classifier.
print('Results of trained classifier', S1classifier.explain());

// Get a confusion matrix and overall accuracy for the training sample.
//var trainAccuracy = S1classifier.confusionMatrix();
//print('Training error matrix', trainAccuracy);
//print('Training overall accuracy', trainAccuracy.accuracy());

var validationS1 = testingS1.classify(S1classifier);
var testAccuracyS1 = validationS1.errorMatrix('landcover', 'classification');
print('Validation error matrix RF: ', testAccuracyS1);
print('Validation overall accuracy RF: ', testAccuracyS1.accuracy());





