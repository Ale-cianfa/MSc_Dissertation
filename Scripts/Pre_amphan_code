Map.centerObject(aoi, 8);

//STEP 2: CALCULATING THE INDECIS AND DOWNLOADING SENTINEL 2 DATA 

//2.1 Select the period of interest 
  //Usually we use pre hurricane season, however, in the bay of bengal there isn't really any time that is not usually hurricane season (mostly up and downs)
    //for now im using 3 months before one of the peaks, which is may, when amphan happened 

var startDate = '2020-01-01';
var endDate = '2020-03-31';
  //This is useful because then we can use the start and end date when downloading S1 data as well

//2.2 function for Calculating Indices 

//NDVI = (NIR-Red)/(NIR+Red)
var addNDVI = function(image) {
return image.addBands(image.normalizedDifference(['B8', 'B4']).rename('NDVI'));
};

//NDWI = (Green-NIR)/(Green-NIR)
var addNDWI = function(image) {
return image.addBands(image.normalizedDifference(['B3', 'B8']).rename('NDWI'));
};

//MNDWI = (Green-SWIR)/(Green+SWIR)
var addMNDWI = function(image) {
return image.addBands(image.normalizedDifference(['B3', 'B6']).rename('MNDWI'));
};

//Simple Ratio (SR) = NIR/Red
var addSR = function(image) {
return image.addBands(image.select('B8').divide(image.select('B4')).rename('SR'));
};

//2.3 Selecting the Sentinel 2 data for the area of interest 
var S2_imagecol = ee.ImageCollection('COPERNICUS/S2')
.filterDate(startDate, endDate)
.filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10)) //filters to get data with less than 15% clouds
.sort('CLOUDY_PIXEL_PERCENTAGE')
.map(addNDVI)
.map(addNDWI)
.map(addMNDWI)
.map(addSR)
//filter according to drawn boundary 
.filterBounds(aoi);

//print('Sentinel 2 Image Collection before CMRI',S2_imagecol);

//Adding the Combined Mangrove Recognition Index (CMRI) = NDVI - NDWI (Yancho et al. 2018)

var addCMRI = function(image) {
return image.addBands(image.select('NDVI').subtract(image.select('NDWI')).rename('CMRI'));
};

var S2 = S2_imagecol.map(addCMRI)

//print(S2)


//NB: There are several ways in wich cloud masking can be done, not sure this is the best one, think about it 

var S2_composite = S2.median();

//print(S2_composite) //this is an image not an image collection

//2.5 Showing the composite images of NDVI, RGB and False colorÃ¹

//Map.addLayer(S2_composite.clip(aoi), {min:0, max:3000, bands:["B4", "B3", "B2"]}, "RGB Composite");
  //Map.addLayer(S2_composite.clip(aoi), {min:0, max:3000, bands:["B8", "B4", "B3"]}, "False color composite");


//print(plotNDVI); //NB: you can download the CSV for the plot from the image 

var classes = Mangroves.merge(NonMangroves); //merging them into a single feature collection

var bands = ['B8','B11','B4','NDVI','MNDWI', 'CMRI', 'SR', 'NDWI']

//old bands --> ['B8','B11','B4','NDVI','MNDWI']; // defyining the bands we care about for the model 

//Create a variable called image to select the bands of interest and clip to geometry
var image = S2_composite.select(bands).clip(aoi);

//print(image);

//Assemble samples for the model
  //this pulls out what values we are seeing for the areas in our training polygons 
var samples = image.sampleRegions({
    collection: classes, // Set of geometries selected for training
    properties: ['landcover'], // Label from each geometry
    scale: 10 // Make each sample the same size as Sentinel pixel
    }).randomColumn('random'); // creates a column with random numbers

//Here we randomly split our samples to set some aside for testing our model's accuracy
//using the "random" column we created
var split = 0.8; // Roughly 80% for training, 20% for testing.
var training = samples.filter(ee.Filter.lt('random', split)); //Subset training data
var testing = samples.filter(ee.Filter.gte('random', split)); //Subset testing data

    
//Print these variables to see how much training and testing data you are using
  // print('Samples n =', samples.aggregate_count('.all'));
  // print('Training n =', training.aggregate_count('.all'));
  // print('Testing n =', testing.aggregate_count('.all'));

//3.2) Begin Random Forest Classification

//.smileRandomForest is used to run the model. Here we run the model using 100 trees
// and 5 randomly selected predictors per split ("(100,5)")
    var classifier = ee.Classifier.smileRandomForest(100,5).train({ 
    features: training.select(['B8','B11','B4','NDVI','MNDWI', 'CMRI', 'SR', 'NDWI','landcover']), //Train using bands and landcover property
    classProperty: 'landcover', //Pull the landcover property from classes
    inputProperties: bands
    });

//View explain to see how each band contributes to the classifier
  
  //print(classifier.explain(),'Explain');

//3.3) Test the accuracy of the model

    //var validation = testing.classify(classifier);
    //var testAccuracy = validation.errorMatrix('Landcover', 'classification');
    //print('Validation error matrix RF: ', testAccuracy);
    //print('Validation overall accuracy RF: ', testAccuracy.accuracy());

//I get a user memory limit issue 
  //link here to try and solve it: https://gis.stackexchange.com/questions/325713/gee-accuracy-assessment-of-classification-user-memory-limit-exceeded
  
//3.4 - Classify the Landsat composite using the Random Forest model
var classifiedrf = image.select(bands) // select the predictors
    .classify(classifier); // .classify applies the Random Forest
                      
//The model results may be "noisy". To reduce noise, create a mask to mask
// unconnected pixels
var pixelcount = classifiedrf.connectedPixelCount(100, false); //Create an image that shows the number of pixels each pixel is connected to
var countmask = pixelcount.select(0).gt(25); //filter out all pixels connected to 4 or less 

//Mask the results to only display mangrove extent
var classMask = classifiedrf.select('classification').gt(0);
var classed = classifiedrf.updateMask(countmask).updateMask(classMask);

//3.5 - Map results

//Add classification to map
//Map.addLayer (classed, {min: 1, max: 1, palette:'blue'}, 'Mangrove Extent pre Irma Optical');

//We can compare this to the new 2017 map of mangroves in the GMW 

//print(classed)
