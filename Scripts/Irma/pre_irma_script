// SETP 1: SETTING UP THE GEOMETRY AND CENTERING THE MAP
  //Right now I want to look at the florida Everglades before Irma in 2017
  // Dates for season: 1/12/2016 to 31/05/2017

Map.centerObject(aoi, 8); //Centering the map view in Earth Engine to my AOI

//STEP 2: CALCULATING THE INDECIS AND DOWNLOADING SENTINEL 2 DATA 

//2.1 SELECT PERIOD OF INTEREST
  //in this case we are going to be using the months pre-hurricane season 2017 
    //This methodology has been widely used to study mangroves and has proven to be appropriate
    
var startDate = '2016-12-01';
var endDate = '2017-05-31';

//Using var start/endDate is useful because then we can use the dates when downloading S1 data as well without having to re-write it

//2.2 CALCULATING INDICES

//NDVI = (NIR-Red)/(NIR+Red)

var addNDVI = function(image) {
return image.addBands(image.normalizedDifference(['B8', 'B4']).rename('NDVI'));
};

//NDWI = (Green-NIR)/(Green-NIR)

var addNDWI = function(image) {
return image.addBands(image.normalizedDifference(['B3', 'B8']).rename('NDWI'));
};

//MNDWI = (Green-SWIR)/(Green+SWIR)

var addMNDWI = function(image) {
return image.addBands(image.normalizedDifference(['B3', 'B6']).rename('MNDWI'));
};

//Simple Ratio (SR) = NIR/Red

var addSR = function(image) {
return image.addBands(image.select('B8').divide(image.select('B4')).rename('SR'));
};

//2.3.1 SELECTING THE SENTINEL DATA

var S2_IC_temp = ee.ImageCollection('COPERNICUS/S2')
//filter start and end date
.filterDate(startDate, endDate)
.map(addNDVI)
.map(addNDWI)
.map(addMNDWI)
.map(addSR)
//filter according to drawn boundary 
.filterBounds(aoi);

print('Sentinel 2 Image Collection before CMRI',S2_IC_temp);

//2.3.2 Adding the Combined Mangrove Recognition Index (CMRI) = NDVI - NDWI (Yancho et al. 2018)

var addCMRI = function(image) {
return image.addBands(image.select('NDVI').subtract(image.select('NDWI')).rename('CMRI'));
};

var S2_IC = S2_IC_temp.map(addCMRI)

//2.4 CLOUD MASKING
var S2withCloudMask = ee.Join.saveFirst('cloud_mask').apply({
primary: S2_IC,
secondary: S2_CLOUD_PROBABILITY,
condition: ee.Filter.equals({leftField: 'system:index', rightField: 'system:index'})
});
S2withCloudMask = ee.ImageCollection(S2withCloudMask);

// define a function to mask-out clouds from each image
var maskClouds = function(img) {
var clouds = ee.Image(img.get('cloud_mask')).select('probability');
var isNotCloud = clouds.lt(10);
return img.mask(isNotCloud);
};

var S2 = S2withCloudMask.map(maskClouds);

//print('Sentinel 2 cloud masked', S2);

// 2.5 CREATING AN IMAGE COMPOSITE USING .MEDIAN()

var S2_composite = S2.median();

//2.6 Showing the composite images of NDVI, RGB and False colorù

Map.addLayer(S2_composite.clip(aoi), {min:0, max:3000, bands:["B4", "B3", "B2"]}, "RGB Composite");
Map.addLayer(S2_composite.clip(aoi), {min:0, max:3000, bands:["B8", "B4", "B3"]}, "False color composite");
Map.addLayer(S2_composite.clip(aoi), {min:-1, max:1, bands:["NDVI"]}, "NDVI Pre Irma");

//2.7 CREATING INDIVIDUAL VARIABLES FOR NDVI AND FALSE COLOR TO EXPORT THEM

//2.7.1 NDVI

var ndvi_S2 = S2.select('NDVI').median().clip(aoi); 
  //here i am making an image of NDVI so i can export it
  //seen similar thing here: https://www.youtube.com/watch?v=qZfiMgwI94o

//NDVI palette
var ndvi_pal = [ '#E7D4E8', '#D9F0D3', '#A6DBA0', '#5AAE61', '#1B7837', '#00441B'];

//2.7.2 FALSE COLOR COMPOSITE

var false_col = S2.select("B8", "B4", "B3").median().clip(aoi);

//2.7.3 RGB COMPOSITE
var RGB = S2.select("B4", "B3", "B2").median().clip(aoi);




//2.8 LINECHART OF NDVI PRE IRMA
var plotNDVI = ui.Chart.image.seriesByRegion(S2, aoi,ee.Reducer.mean(),
              'NDVI',500, 'system:time_start', 'system:index')
              .setChartType('LineChart').setOptions({
              title: 'NDVI pre-Irma time series',
              hAxis: {title: 'Date'},
              vAxis: {title: 'NDVI'}
                
              });

print(plotNDVI); //NB: you can download the CSV for the plot from the image 

//STEP 3: SETTING UP THE RANDOM FOREST CLASSIFIER 

//3.1 PREPARING TRAINING DATA

var classes = Mangroves.merge(NonMangrove); //merging the training data selected from the map in a single feature collection

var bands = ['B8','B11','B4','NDVI','MNDWI', 'CMRI', 'SR', 'NDWI']

//Create a variable called image to select the bands of interest and clip to geometry

var image = S2_composite.select(bands).clip(aoi);

print(image);

//3.1 ASSEMBLING SAMPLES FOR THE MODEL
  //This pulls out what values we are seeing for the areas in our training polygons 
  
var samples = image.sampleRegions({
    collection: classes, // Set of geometries selected for training (mangrove and non mangrove)
    properties: ['landcover'], // Label from each geometry (1 and 0 value respectively)
    scale: 10 //each sample is the sentinel res size (nb: this can be quite computationally heavy so this can be changed to 30 if the calcualtion times out)
    }).randomColumn('random'); // creates a column with random numbers

//3.2 TRAIN/TEST SPLIT
  //Here we randomly split our samples to set some aside for testing our model's accuracy
  //using the "random" column we created
  
var split = 0.8; //80% for training, 20% for testing, 70/30 is also a good split

var training = samples.filter(ee.Filter.lt('random', split)); //Subset training data
var testing = samples.filter(ee.Filter.gte('random', split)); //Subset testing data

    
//Print these variables to see how much training and testing data you are using

print('Samples n =', samples.aggregate_count('.all'));
print('Training n =', training.aggregate_count('.all'));
print('Testing n =', testing.aggregate_count('.all'));

//3.3 RANDOM FOREST CLASSIFIER 
//.smileRandomForest is used to run the model. Here we run the model using 100 trees and 5 randomly selected predictors per split ("(100,5)")

var classifier = ee.Classifier.smileRandomForest(100,5).train({ 
    features: training.select(['B8','B11','B4','NDVI','MNDWI', 'CMRI', 'SR', 'NDWI','landcover']), //Train using bands and landcover property
    classProperty: 'landcover', //Pull the landcover property from classes
    inputProperties: bands
    });

print(classifier.explain(),'Explain'); //This explains how each variable influences the model 

//3.4 TESTING THE ACCURACY OF THE MODEL

var validation = testing.classify(classifier);
var testAccuracy = validation.errorMatrix('Landcover', 'classification');

print('Validation error matrix RF: ', testAccuracy);
print('Validation overall accuracy RF: ', testAccuracy.accuracy());

//I get a user memory limit issue 
  //link here to try and solve it: https://gis.stackexchange.com/questions/325713/gee-accuracy-assessment-of-classification-user-memory-limit-exceeded

//NB: the explain and accuracy testing is a really computationally intensive process so the calcuation is likely to time out (or use all the user memory)
  //in this case, is worth just commenting everything that is not useful out so that these few lines can run more smoothly 

//3.5 CLASSIFYING THE SENTINEL DATA USING THE RESULTS OF THE RF

var classifiedrf = image.select(bands) // select the predictors
    .classify(classifier); // .classify applies the RF
 
//3.6 REDUCING NOISE
  //The model results may be "noisy". To reduce noise, create a mask to mask unconnected pixels --> this is very optional 

var pixelcount = classifiedrf.connectedPixelCount(100, false); //Create an image that shows the number of pixels each pixel is connected to
var countmask = pixelcount.select(0).gt(25); //filter out all pixels connected to 4 or less 

//Mask the results to only display mangrove extent
var classMask = classifiedrf.select('classification').gt(0);
var classed = classifiedrf.updateMask(countmask).updateMask(classMask);


//3.7 MAPPING THE RESULTS

//Add classification to map
//Map.addLayer (classed, {min: 1, max: 1, palette:'blue'}, 'Mangrove Extent pre Irma Optical');

//We can compare this to the new GMW map as well as the one we will produce using sentinel 1 data s well 

//3.8 VECTORISING THE RESULTS TO RUN THE CODE MORE SMOOTHLY
  //commenting this off cause it was successful
  
var mangS2 = classed.reduceToVectors({ geometry:aoi,
scale:10, //this can be reduced to 30 if the calculation times out
geometryType: 'polygon', 
maxPixels:1e13,
labelProperty: 'class',});

//Exporting the vector to assets 
  //this will allow us to have the sentinel 2 mangrove map in the GEE assets and it will make it possible to essentially comment all the previous code 
    //out and run the following steps much more smoothly (because GEE doesn't have to classify sentinel 2 data again and again everytime we run the script) 
    
Export.table.toAsset({
collection: mangS2, 
description:'Vectorised_preIrma'});

//STEP 4: ADDING SENTINEL-1 SAR DATA 

//4.1 FILTERING SENTINEL 1 TO AREA AND DATES OF INTEREST 

var sentinel1 = ee.ImageCollection('COPERNICUS/S1_GRD')
            .filterDate(startDate, endDate)
            .filterBounds(aoi)
            .filter(ee.Filter.eq('resolution_meters',10));

print('Sentinel 1 data', sentinel1); 
  //NB: is useful to "print" a lot in the console just to check we are doing things right, but these can be removed if the are timing out issues

//4.2 GETTING S1 DUAL POLARISATION

//4.2.1 Filter by metadata properties.
var vh = sentinel1

  //Filter to get images with VV and VH dual polarization.
  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))
  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'))
  
  //Filter to get images collected in interferometric wide swath mode.
  .filter(ee.Filter.eq('instrumentMode', 'IW'));
  
//4.2.2 Filter to get images from different look angles.
var vhAscending = vh.filter(ee.Filter.eq('orbitProperties_pass', 'ASCENDING'));
var vhDescending = vh.filter(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'));

//4.3 CREATING A COMPOSITE OF DIFF POLARISATIONS AND LOOK ANGLES
var S1composite = ee.Image.cat([
  vhAscending.select('VH').mean(),
  ee.ImageCollection(vhAscending.select('VV').merge(vhDescending.select('VV'))).mean(),
  vhDescending.select('VH').mean()
]).focal_median();

print('S1 Composite', S1composite);

//4.4 DISPLAYING THE RESULTS OF S1 
  //I.E: Display as a composite of polarization and backscattering characteristics.
Map.addLayer(S1composite.clip(aoi), {min: [-25, -20], max: [0, 10]}, 'Sentinel Composite');

//STEP 5: REBUILDING A RFC WITH THE SAR DATA 
  //in this case we are going to be using the same training data
   //essentially we use SAR as a way to improve on mangrove classification to make it more precise and in order to include structure as well 

//5.1 CLIPPING S1 OBSERVATIONS TO S2 RESULTS (using the vectorised asset) 

var FinalComposite = S1composite.clip(mangS2);
print('Final Composite',FinalComposite) //così mi dice che ha solo due bands 

//5.2 ASSEMBLING THE SAMPLES USED FOR THE MODEL

var S1bands = ['VV','VH']; //bands I want in the model

var S1samples = FinalComposite.select(S1bands).sampleRegions({
collection: classes, // Set of geometries selected earlier
properties: ['landcover'], // Label from each geometry
scale: 10 // Make each sample the same size as S1 pixel
}).randomColumn('random_S1'); // creates a column with random numbers


var splitS1 = 0.8; 
var trainingS1 = S1samples.filter(ee.Filter.lt('random_S1', split)); 
var testingS1 = S1samples.filter(ee.Filter.gte('random_S1', split)); 

    
//Print these variables to see how much training and testing data you are using
print('Samples n =', S1samples.aggregate_count('.all'));
print('Training n =', trainingS1.aggregate_count('.all'));
print('Testing n =', testingS1.aggregate_count('.all'));
    
    
//5.3 RF CLASSIFICATION

var S1classifier = ee.Classifier.smileRandomForest(100,2).train({ //We use 2 variables instead of 5
features: trainingS1.select(['VV','VH', 'landcover']), //S1samples
classProperty: 'landcover',
inputProperties: S1bands
});

//5.4 CLASSIFYING S1 WITH THE RESULTS 

var S1classified = FinalComposite.select(S1bands) // select the predictors
.classify(S1classifier); // apply the Random Forest
 
//5.5 REMOVING NOISE (like above) 

var S1pixelcount = S1classified.connectedPixelCount(100, false); 
var S1countmask = S1pixelcount.select(0).gt(10);

//5.6 MASKING THE RESULTS TO ONLY SHOW MANGROVE EXTENT 

var S1classMask = S1classified.select('classification').gt(0);
var S1classed=  S1classified.updateMask(S1countmask).updateMask(S1classMask);

//5.7 MAPPING THE RESULTS 

//Add classification to map
  
Map.addLayer (GMW_16, {color:'#8d5a99'}, 'GMW 2016'); //global mangrove watch 2016 map for comparison 
Map.addLayer (S1classed, {min: 1, max: 1, palette: '#457b9d'}, 'Mangrove Extent pre Irma SAR'); //land class including sar data
Map.addLayer (classed, {min: 1, max: 1, palette:'#8d5a99'}, 'Mangrove Extent pre Irma Optical'); //optical land class

//Based on this there is a big difference between only optical and optical as well as SAR
  //much more detail on meadirng fjord like islands
  //much more detail about mangroves in the inside and surrounding the lakes   
  
//STEP 6: EVALUATING THE MODEL

//6.1 ACCURACY OF THE MODEL 
  //link here: https://developers.google.com/earth-engine/apidocs/ee-classifier-smilerandomforest
  
//Get information about the trained classifier.

//print('Results of trained classifier', S1classifier.explain());

// Get a confusion matrix and overall accuracy for the training sample.
var trainAccuracy = S1classifier.confusionMatrix();
print('Training error matrix', trainAccuracy);
print('Training overall accuracy', trainAccuracy.accuracy());

var validationS1 = testingS1.classify(S1classifier);
var testAccuracyS1 = validationS1.errorMatrix('landcover', 'classification');

print('Validation error matrix RF: ', testAccuracyS1);
print('Validation overall accuracy RF: ', testAccuracyS1.accuracy());

//6.2 CALCULATING THE PRE-IRMA MANGROVE AREA

//Use reduceRegion with a Sum reducer to calculate total area in ha

var getPI = S1classed.multiply(ee.Image.pixelArea()).divide(10000).reduceRegion({
   reducer:ee.Reducer.sum(),
   geometry:aoi,
   scale: 50,
   maxPixels:1e13,
   tileScale: 16
}).get('classification');

 print(getPI, 'Mangrove Extent pre Irma in ha');
 
 //NB: calculting the area is also computationally intensive so this can be commented out in case
 
 
 
 

