// SETP 1: SETTING UP THE GEOMETRY AND CENTERING THE MAP

Map.centerObject(aoi, 8);

//STEP 2: CALCULATING THE INDECIS AND DOWNLOADING SENTINEL 2 DATA 

//2.1 Select the period of interest 
  //in this case we are going to be using the months post-hurricane season 2017 (Between 2017 and 2018) 

var startDate = '2017-12-01';
var endDate = '2018-05-31';

//NB: this methodology works well in the atlantic where seasonality is well defined, in other places, like the Indian ocean, it doesn't work quite as well 

//2.2 function for Calculating Indices 

//NDVI = (NIR-Red)/(NIR+Red)

var addNDVI = function(image) {
return image.addBands(image.normalizedDifference(['B8', 'B4']).rename('NDVI'));
};

//NDWI = (Green-NIR)/(Green-NIR)

var addNDWI = function(image) {
return image.addBands(image.normalizedDifference(['B3', 'B8']).rename('NDWI'));
};

//MNDWI = (Green-SWIR)/(Green+SWIR)

var addMNDWI = function(image) {
return image.addBands(image.normalizedDifference(['B3', 'B6']).rename('MNDWI'));
};

//Simple Ratio (SR) = NIR/Red

var addSR = function(image) {
return image.addBands(image.select('B8').divide(image.select('B4')).rename('SR'));
};

//2.3 Selecting the Sentinel 2 data for the area of interest 

var S2_imagecol = ee.ImageCollection('COPERNICUS/S2')

//filter start and end date
.filterDate(startDate, endDate)
.filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10)) //filters to get data with less than 10% clouds
.sort('CLOUDY_PIXEL_PERCENTAGE')
//this is a different methodology but it works just as well
.map(addNDVI)
.map(addNDWI)
.map(addMNDWI)
.map(addSR)

//filter according to drawn boundary 
.filterBounds(aoi);

//Adding the Combined Mangrove Recognition Index (CMRI) = NDVI - NDWI (Yancho et al. 2018)

var addCMRI = function(image) {
return image.addBands(image.select('NDVI').subtract(image.select('NDWI')).rename('CMRI'));
};

var S2_2017 = S2_imagecol.map(addCMRI)

print('Sentinel 2', S2_2017);

//Creating an image composite using .median()

var S2_composite = S2_2017.median();

//2.5 Showing the composite images of NDVI, RGB and False colorù

Map.addLayer(S2_composite.clip(aoi), {min:0, max:3000, bands:["B4", "B3", "B2"]}, "RGB Composite");
Map.addLayer(S2_composite.clip(aoi), {min:0, max:3000, bands:["B8", "B4", "B3"]}, "False color composite");

//NDVI 

//Creating an NDVI palette
var ndvi_pal = [ '#E7D4E8', '#D9F0D3', '#A6DBA0', '#5AAE61', '#1B7837', '#00441B'];

var ndvi_S2 = S2_2017.select('NDVI').median().clip(aoi); //here i am making an image of NDVI so i can export it
  //seen similar thing here: https://www.youtube.com/watch?v=qZfiMgwI94o

//Display NDVI results on map
Map.addLayer(ndvi_S2, {min: 0, max: 1, palette: ndvi_pal}, 'NDVI S2');

//False color composite

var false_col = S2_2017.select("B8", "B4", "B3").median().clip(aoi);
Map.addLayer(false_col, {min: 0, max: 3000}, 'False color composite');

//RGB composite 

var RGB = S2_2017.select("B4", "B3", "B2").median().clip(aoi);
Map.addLayer(RGB, {min: 0, max: 3000}, 'RGB Composite');

//2.6 Creating a Linechart for NDVI pro

var plotNDVI = ui.Chart.image.seriesByRegion(S2_2017, aoi,ee.Reducer.mean(),
              'NDVI',500, 'system:time_start', 'system:index')
              .setChartType('LineChart').setOptions({
              title: 'NDVI post-Irma time series',
              hAxis: {title: 'Date'},
              vAxis: {title: 'NDVI'}
                
              });
              
print(plotNDVI);

//3.1 Preparing training data and predictors

var classes = Mangroves.merge(NonMangrove); //merging them into a single feature collection

  //var bands = ['B8','B11','B4','NDVI','MNDWI', 'CMRI', 'SR', 'NDWI']

//Create a variable called image to select the bands of interest and clip to geometry
var image = S2_composite.select(bands).clip(aoi);

//print(image);

//Assemble samples for the model
  //this pulls out what values we are seeing for the areas in our training polygons 
  
var samples = image.sampleRegions({
   collection: classes, // Set of geometries selected for training
   properties: ['landcover'], // Label from each geometry
   scale: 10 // Make each sample the same size as Sentinel pixel
   }).randomColumn('random'); // creates a column with random numbers

//Here we randomly split our samples to set some aside for testing our model's accuracy
    //using the "random" column we created

var split = 0.8; 
var training = samples.filter(ee.Filter.lt('random', split)); //Subset training data
var testing = samples.filter(ee.Filter.gte('random', split)); //Subset testing data

    
//Print these variables to see how much training and testing data you are using
print('Samples n =', samples.aggregate_count('.all'));
print('Training n =', training.aggregate_count('.all'));
print('Testing n =', testing.aggregate_count('.all'));

//3.2) Begin Random Forest Classification
    //.smileRandomForest is used to run the model. Here we run the model using 100 trees
    // and 5 randomly selected predictors per split ("(100,5)")

var classifier = ee.Classifier.smileRandomForest(100,5).train({ 
features: training.select(['B8','B11','B4','NDVI','MNDWI', 'CMRI', 'SR', 'NDWI','landcover']), //Train using bands and landcover property
classProperty: 'landcover', //Pull the landcover property from classes
inputProperties: bands
});

//View explain to see how each band contributes to the classifier
  
print(classifier.explain(),'Explain');

//3.3) Test the accuracy of the model

var validation = testing.classify(classifier);
var testAccuracy = validation.errorMatrix('Landcover', 'classification');
print('Validation error matrix RF: ', testAccuracy);
print('Validation overall accuracy RF: ', testAccuracy.accuracy());

//I get a user memory limit issue 
  //link here to try and solve it: https://gis.stackexchange.com/questions/325713/gee-accuracy-assessment-of-classification-user-memory-limit-exceeded
  
//3.4 - Classify the Landsat composite using the Random Forest model

var classifiedrf = image.select(bands) // select the predictors
    .classify(classifier); // .classify applies the Random Forest
                      
//Removing Noise

var pixelcount = classifiedrf.connectedPixelCount(100, false); //Create an image that shows the number of pixels each pixel is connected to
var countmask = pixelcount.select(0).gt(25); //filter out all pixels connected to 4 or less 

//Mask the results to only display mangrove extent

var classMask = classifiedrf.select('classification').gt(0);
var classed = classifiedrf.updateMask(countmask).updateMask(classMask);


//3.5 - Map results

Map.addLayer (classed, {min: 1, max: 1, palette:'blue'}, 'Mangrove Extent post Irma Optical');

//Vectorising the results 

var mangVect = classed.reduceToVectors({ geometry:aoi,
    scale:10,
    geometryType: 'polygon', 
    maxPixels:1e13,
   labelProperty: 'class',});
   
//Exporting the vector to GEE asset 
Export.table.toAsset({
    collection: mangVect, 
    description:'Vectorised_postIrma'});

//STEP 4: ADDING SENTINEL 1 DARA
var sentinel1 = ee.ImageCollection('COPERNICUS/S1_GRD')
            .filterDate(startDate, endDate)
            .filterBounds(aoi)
            .filter(ee.Filter.eq('resolution_meters',10));

  //print('Sentinel 1 data', sentinel1);

//4.2) Get Sentinel's dual polarization

// Filter by metadata properties.
var vh = sentinel1
  //Filter to get images with VV and VH dual polarization.
  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))
  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'))
  // Filter to get images collected in interferometric wide swath mode.
  .filter(ee.Filter.eq('instrumentMode', 'IW'));
  
// Filter to get images from different look angles.
var vhAscending = vh.filter(ee.Filter.eq('orbitProperties_pass', 'ASCENDING'));
var vhDescending = vh.filter(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'));

//4.3) Create a composite from means at different polarizations and look angles.
var S1composite = ee.Image.cat([
  vhAscending.select('VH').mean(),
  ee.ImageCollection(vhAscending.select('VV').merge(vhDescending.select('VV'))).mean(),
  vhDescending.select('VH').mean()
]).focal_median();

//print('S1 Composite', S1composite);

//4.4) Display results
//Display as a composite of polarization and backscattering characteristics.

  //Map.addLayer(S1composite.clip(aoi), {min: [-25, -20], max: [0, 10]}, 'Sentinel Composite');

//STEP 5: REBUILDING A RFC WITH THE SAR DATA 
  //in this case we are going to be using the same training data
    //essentially we use SAR as a way to improve on mangrove classification to make it more precise and in order to include structure as well 

//5.1 Clipping Sentinel 1 observations to sentinel 2 results (this is done using the vectorised pre irma land class)

var FinalComposite = S1composite.clip(postIrma);
print('Final Composite',FinalComposite) //così mi dice che ha solo due bands 

//5.2 Assembling samples that are going to be used for the model

var S1bands = ['VV','VH']; //bands I want in the model

var S1samples = FinalComposite.select(S1bands).sampleRegions({
collection: classes, // Set of geometries selected in 4.1
properties: ['landcover'], // Label from each geometry
scale: 30 // Make each sample the same size as Landsat pixel
}).randomColumn('random_S1'); // creates a column with random numbers


var splitS1 = 0.8; // Roughly 80% for trining, 20% for testing.
var trainingS1 = S1samples.filter(ee.Filter.lt('random_S1', splitS1)); //Subset training data
var testingS1 = S1samples.filter(ee.Filter.gte('random_S1', splitS1)); //Subset testing data

    
//Print these variables to see how much training and testing data you are using
  //print('Samples n =', S1samples.aggregate_count('.all'));
  //print('Training n =', trainingS1.aggregate_count('.all'));
  //print('Testing n =', testingS1.aggregate_count('.all'));
    
    
//5.3 Begin Random Forest Classification

var S1classifier = ee.Classifier.smileRandomForest(100,2).train({ //We use 2 variables instead of 5
features: trainingS1.select(['VV','VH', 'landcover']), //S1samples
classProperty: 'landcover',
inputProperties: S1bands
});


//5.4 Classify the Sentinel composite using the Random Forest model
var S1classified = FinalComposite.select(S1bands) // select the predictors
.classify(S1classifier); // apply the Random Forest
 
//The model results may be "noisy". To reduce noise, create a mask to mask
// unconnected pixels

var S1pixelcount = S1classified.connectedPixelCount(100, false); //Create an image that shows the number of pixels each pixel is connected to
var S1countmask = S1pixelcount.select(0).gt(25); //filter out all pixels connected to 4 or less 

//Mask the results to only display mangrove extent

var S1classMask = S1classified.select('classification').gt(0);
var S1classed=  S1classified.updateMask(S1countmask).updateMask(S1classMask);

//5.5 Map results

//Add classification to map
  
Map.addLayer (S1classed, {min: 1, max: 1, palette: '#606c38'}, 'Mangrove Extent pre Irma SAR');

//Based on this there is a big difference between only optical and optical as well as SAR
  //much more detail on meadirng fjord like islands
  //much more detail about mangroves in the inside and surrounding the lakes 
  //can be also 
  
Export.image.toDrive({
  image: S1classed,
  description: 'Landclass_postIrma_yr0',
  scale: 10,
  region: aoi,
  fileFormat: 'GeoTIFF',
  maxPixels: 1e13
});

//STEP 6: EVALUATING THE MODEL
//6.1. Using the testing data to find the accuracy of the model with confusion matric 
  //link here: https://developers.google.com/earth-engine/apidocs/ee-classifier-smilerandomforest
  
// Get information about the trained classifier.

//print('Results of trained classifier', S1classifier.explain());

// Get a confusion matrix and overall accuracy for the training sample.

//var trainAccuracy = S1classifier.confusionMatrix();
//print('Training error matrix', trainAccuracy);
//print('Training overall accuracy', trainAccuracy.accuracy());


//var validationS1 = testingS1.classify(S1classifier);
//var testAccuracyS1 = validationS1.errorMatrix('landcover', 'classification');

//print('Validation error matrix RF: ', testAccuracyS1);
//print('Validation overall accuracy RF: ', testAccuracyS1.accuracy());

//6.2) Calculate Pre-Irma Mangrove Area 2016/17

//Use reduceRegion with a Sum reducer to calculate total area

var getPI = S1classed.multiply(ee.Image.pixelArea()).divide(10000).reduceRegion({
   reducer:ee.Reducer.sum(),
   geometry:aoi,
   scale: 50,
   maxPixels:1e13,
   tileScale: 16
}).get('classification');

print(getPI, 'Mangrove Extent post Irma in ha');
